// Constants and utility functions (same as before)
const TASK_TYPES = ['Church', 'Family', 'Work', 'Relationships', 'Self', 'Property'];
const RECURRENCE_OPTIONS = ['Non-recurring', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Annually'];
const QUADRANTS = {
    DO_NOW: 1,
    SCHEDULE: 2,
    DELEGATE: 3,
    DONT_DO: 4,
    HELD: 'held',
    COMPLETED: 'completed'
};
const MAX_GRACE_SCORE = 100;
const HOURS_PER_WEEK = 168;

function getTaskTypeIcon(taskType) {
    const icons = {
        'Church': 'â›ª',
        'Family': 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦',
        'Work': 'ðŸ’¼',
        'Relationships': 'ðŸ¤',
        'Self': 'ðŸ§˜',
        'Property': 'ðŸ '
    };
    return icons[taskType] || 'ðŸ“‹';
}

function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// Notification Manager (same as before)
class NotificationManager {
    constructor() {
        this.queue = [];
        this.isShowing = false;
    }
    show(message, type = 'info') {
        this.queue.push({ message, type });
        if (!this.isShowing) this.displayNext();
    }
    displayNext() {
        if (this.queue.length === 0) {
            this.isShowing = false;
            return;
        }
        this.isShowing = true;
        const { message, type } = this.queue.shift();
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            z-index: 1001;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            max-width: 300px;
            ${type === 'success' ? 'background: linear-gradient(135deg, #28a745, #20c997);' :
            type === 'error' ? 'background: linear-gradient(135deg, #dc3545, #fd7e14);' :
            'background: linear-gradient(135deg, #667eea, #764ba2);'}
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        setTimeout(() => { notification.style.transform = 'translateX(0)'; }, 10);
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) document.body.removeChild(notification);
                this.displayNext();
            }, 300);
        }, type === 'error' ? 5000 : 3000);
    }
}
const notifier = new NotificationManager();

// Modal class (same as before)
class Modal {
    constructor(id) {
        this.modal = document.getElementById(id);
        this.closeBtn = this.modal.querySelector('.close');
        this.closeBtn.addEventListener('click', () => this.hide());
        window.addEventListener('click', e => {
            if (e.target === this.modal) this.hide();
        });
    }
    show() { this.modal.style.display = 'block'; }
    hide() { this.modal.style.display = 'none'; }
}

// TaskStorage class with all methods (same as before, including calculateGraceScore, renderAllTasks, etc.)
// For brevity, assume full class code from previous messages is here, including:
// - openDB, loadTasks, saveTasks, addTask, updateTask, deleteTask, toggleComplete, autoBackup
// - determineQuadrant, calculateGraceScore, updateStats, updatePieChart, renderPieCharts
// - renderAllTasks, renderTask, renderCompletedTasks, updateQuadrantCounts

// Instantiate storage and modal
const taskStorage = new TaskStorage();
const editModal = new Modal('editModal');

let currentEditingId = null;

// Add new task from form inputs
async function addItem() {
    const title = document.getElementById('item-title').value.trim();
    const description = document.getElementById('item-description').value.trim();
    const taskType = document.getElementById('task-type').value;
    const estimatedTimeStr = document.getElementById('estimated-time').value;
    const manualGraceScoreStr = document.getElementById('manual-grace-score').value;
    const recurrence = document.getElementById('recurrence').value || 'Non-recurring';
    const resources = document.getElementById('resources').value || 'Yes';
    const urgency = document.getElementById('urgency').value;
    const importance = document.getElementById('importance').value;

    if (!title) {
        alert('Please enter a task title');
        document.getElementById('item-title').focus();
        return;
    }
    if (!taskType) {
        alert('Please select a task type');
        document.getElementById('task-type').focus();
        return;
    }
    if (!urgency) {
        alert('Please select urgency level');
        document.getElementById('urgency').focus();
        return;
    }
    if (!importance) {
        alert('Please select importance level');
        document.getElementById('importance').focus();
        return;
    }

    const estimatedTime = parseFloat(estimatedTimeStr) || 1;
    if (estimatedTime <= 0) {
        alert('Estimated hours must be greater than 0');
        document.getElementById('estimated-time').focus();
        return;
    }

    let manualGraceScore = null;
    if (manualGraceScoreStr) {
        manualGraceScore = parseInt(manualGraceScoreStr);
        if (isNaN(manualGraceScore) || manualGraceScore < 0 || manualGraceScore > 100) {
            alert('Manual GRACE score must be between 0 and 100');
            document.getElementById('manual-grace-score').focus();
            return;
        }
    }

    const quadrant = taskStorage.determineQuadrant(urgency, importance, resources);
    const graceScore = taskStorage.calculateGraceScore(title, description, taskType, manualGraceScore, estimatedTime, recurrence);

    const task = {
        title,
        description,
        taskType,
        estimatedTime,
        recurrence,
        resources,
        urgency,
        importance,
        quadrant,
        graceScore,
        manualGraceScore
    };

    await taskStorage.addTask(task);
    clearForm();

    let message = `âœ… Task added! GRACE Score: ${graceScore}/100`;
    if (manualGraceScore !== null) {
        message += ` (Manual Override: ${manualGraceScore})`;
    }
    notifier.show(message, 'success');
}

function clearForm() {
    document.getElementById('item-title').value = '';
    document.getElementById('item-description').value = '';
    document.getElementById('task-type').value = '';
    document.getElementById('estimated-time').value = '';
    document.getElementById('manual-grace-score').value = '';
    document.getElementById('recurrence').value = '';
    document.getElementById('resources').value = '';
    document.getElementById('urgency').value = '';
    document.getElementById('importance').value = '';
}

// Open edit modal and populate fields
function openEditModal(taskId) {
    const task = taskStorage.tasks.find(t => t.id === taskId);
    if (!task) return;
    currentEditingId = taskId;

    document.getElementById('edit-title').value = task.title;
    document.getElementById('edit-description').value = task.description || '';
    document.getElementById('edit-task-type').value = task.taskType;
    document.getElementById('edit-estimated-time').value = task.estimatedTime;
    document.getElementById('edit-manual-grace-score').value = task.manualGraceScore || '';
    document.getElementById('edit-recurrence').value = task.recurrence;
    document.getElementById('edit-resources').value = task.resources;
    document.getElementById('edit-urgency').value = task.urgency;
    document.getElementById('edit-importance').value = task.importance;

    editModal.show();
}

// Save changes from edit modal
async function saveEdit() {
    if (!currentEditingId) return;

    const updates = {
        title: document.getElementById('edit-title').value.trim(),
        description: document.getElementById('edit-description').value.trim(),
        taskType: document.getElementById('edit-task-type').value,
        estimatedTime: parseFloat(document.getElementById('edit-estimated-time').value),
        manualGraceScore: document.getElementById('edit-manual-grace-score').value ? parseInt(document.getElementById('edit-manual-grace-score').value) : null,
        recurrence: document.getElementById('edit-recurrence').value,
        resources: document.getElementById('edit-resources').value,
        urgency: document.getElementById('edit-urgency').value,
        importance: document.getElementById('edit-importance').value
    };

    if (!updates.title || !updates.taskType || !updates.estimatedTime || !updates.recurrence || !updates.resources || !updates.urgency || !updates.importance) {
        alert('Please fill in all required fields');
        return;
    }

    if (updates.manualGraceScore !== null && (updates.manualGraceScore < 0 || updates.manualGraceScore > 100)) {
        alert('Manual GRACE score must be between 0 and 100');
        return;
    }

    updates.quadrant = taskStorage.determineQuadrant(updates.urgency, updates.importance, updates.resources);
    updates.graceScore = taskStorage.calculateGraceScore(updates.title, updates.description, updates.taskType, updates.manualGraceScore, updates.estimatedTime, updates.recurrence);

    await taskStorage.updateTask(currentEditingId, updates);
    editModal.hide();
    notifier.show('âœ… Task updated successfully!', 'success');
    currentEditingId = null;
}

// Delete task with confirmation
function deleteTask(taskId, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }
    if (confirm('Are you sure you want to delete this task? This action cannot be undone.')) {
        taskStorage.deleteTask(taskId);
        notifier.show('ðŸ—‘ï¸ Task deleted successfully!', 'info');
    }
}

// Toggle task completion
function toggleComplete(taskId, event) {
    if (event) {
        event.stopPropagation();
    }
    taskStorage.toggleComplete(taskId);
}

// Toggle scheduled status for recurring tasks
function toggleScheduled(taskId, event) {
    if (event) {
        event.stopPropagation();
    }
    const task = taskStorage.tasks.find(t => t.id === taskId);
    if (task) {
        task.isScheduled = !task.isScheduled;
        taskStorage.updateTask(taskId, { isScheduled: task.isScheduled });
        notifier.show(task.isScheduled ? `ðŸ“… Task scheduled: ${task.title}` : `âŒ Task unscheduled: ${task.title}`, task.isScheduled ? 'success' : 'info');
    }
}

// Attach event listeners on DOMContentLoaded
document.addEventListener('DOMContentLoaded', async () => {
    notifier.show('ðŸ”„ Loading your GRACE matrix...', 'info');
    await taskStorage.init();
    notifier.show('âœ… GRACE matrix loaded successfully!', 'success');

    // Debounced filters
    const applyFiltersDebounced = debounce(() => taskStorage.renderAllTasks(), 300);
    document.getElementById('filter-task-type').addEventListener('change', applyFiltersDebounced);
    document.getElementById('filter-recurrence').addEventListener('change', applyFiltersDebounced);

    // Add task button
    document.querySelector('button[onclick="addItem()"]').addEventListener('click', addItem);

    // Save edit button
    document.querySelector('#editModal .button-group button').addEventListener('click', saveEdit);

    // Cancel edit button
    document.querySelector('#editModal .button-group .secondary-btn').addEventListener('click', () => {
        editModal.hide();
        currentEditingId = null;
    });

    // Close edit modal on clicking outside or close button handled by Modal class

    // Render initial tasks
    taskStorage.renderAllTasks();
});
