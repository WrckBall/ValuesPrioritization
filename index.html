
</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Brian's Values-Driven Prioritization</h1>
            <div class="grace-subtitle" style="font-size: 1.1em; font-weight: bold; color: #2c3e50;">My Why - G.R.A.C.E</div>
            <div class="grace-framework">
                <div class="grace-items">
                    <div class="grace-item">🙏 <strong>G</strong>lorify God</div>
                    <div class="grace-item">👥 <strong>R</strong>aise Up Teams</div>
                    <div class="grace-item">🏗️ <strong>A</strong>rchitect Systems</div>
                    <div class="grace-item">💡 <strong>C</strong>reate Solutions</div>
                    <div class="grace-item">🌟 <strong>E</strong>nrich Others</div>
                </div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="completion-progress"></div>
        </div>
        
        <!-- Filter Controls -->
        <div class="filter-section">
            <h3>Filter Tasks</h3>
            <div class="filter-controls">
                <select id="filter-task-type">
                    <option value="">All Task Types</option>
                    <option value="Church">⛪ Church</option>
                    <option value="Family">👨‍👩‍👧‍👦 Family</option>
                    <option value="Work">💼 Work</option>
                    <option value="Relationships">🤝 Relationships</option>
                    <option value="Self">🧘 Self</option>
                    <option value="Property">🏠 Property</option>
                </select>
                <select id="filter-recurrence">
                    <option value="">All Recurrence Levels</option>
                    <option value="Non-recurring">📅 Non-recurring</option>
                    <option value="Daily">🔄 Daily</option>
                    <option value="Weekly">📊 Weekly</option>
                    <option value="Monthly">🗓️ Monthly</option>
                    <option value="Quarterly">📈 Quarterly</option>
                    <option value="Annually">📆 Annually</option>
                </select>
                <button onclick="clearFilters()" class="secondary-btn">Clear Filters</button>
            </div>
        </div>
        
        <!-- Filtered Stats Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-number" id="total-tasks">0</span>
                <span class="stat-label">Total Tasks</span>
            </div>
            <div class="stat-item">
                <span class="stat-number" id="total-hours">0</span>
                <span class="stat-label">Total Hours</span>
            </div>
            <div class="stat-item">
                <span class="stat-number" id="combined-grace">0</span>
                <span class="stat-label">G.R.A.C.E</span>
            </div>
        </div>
        
        <div class="time-allocation-chart">
            <div class="chart-title">Weekly Time Allocation</div>
            <div class="charts-container">
                <div class="chart-section">
                    <h4>Percentage of Week</h4>
                    <div class="pie-chart" id="percentage-chart-container">
                        <!-- Percentage pie chart will be generated here -->
                    </div>
                </div>
                <div class="chart-section">
                    <h4>Hours per Week</h4>
                    <div class="pie-chart" id="hours-chart-container">
                        <!-- Hours pie chart will be generated here -->
                    </div>
                </div>
            </div>
            <!-- Single shared legend for both charts -->
            <div class="chart-legend" id="shared-legend">
                <!-- Shared legend will be generated here -->
            </div>
            <div class="unutilized-time-display">
                <div class="unutilized-title">Unutilized Time Remaining:</div>
                <div class="unutilized-values">
                    <span id="unutilized-percentage">100.0%</span> or <span id="unutilized-hours">168.0 hrs</span>
                </div>
            </div>
        </div>
        
        <div class="matrix-container">
            <div class="quadrant quadrant-2">
                <div class="quadrant-title">
                    📅 SCHEDULE
                    <span class="quadrant-count" id="count-2">0</span>
                </div>
                <div class="quadrant-subtitle">Important • Not Urgent</div>
                <div class="items-list" id="quadrant-2-items"></div>
                <div class="quadrant-performance-score" id="performance-2">Perf: 0%</div>
                <div class="quadrant-grace-score" id="grace-2">G.R.A.C.E: 0</div>
            </div>
            
            <div class="quadrant quadrant-1">
                <div class="quadrant-title">
                    🔥 DO NOW
                    <span class="quadrant-count" id="count-1">0</span>
                </div>
                <div class="quadrant-subtitle">Important • Urgent</div>
                <div class="items-list" id="quadrant-1-items"></div>
                <div class="quadrant-grace-score" id="grace-1">G.R.A.C.E: 0</div>
            </div>
            
            <div class="quadrant quadrant-4">
                <div class="quadrant-title">
                    🚫 DON'T DO
                    <span class="quadrant-count" id="count-4">0</span>
                </div>
                <div class="quadrant-subtitle">Not Important • Not Urgent</div>
                <div class="items-list" id="quadrant-4-items"></div>
                <div class="quadrant-grace-score" id="grace-4">G.R.A.C.E: 0</div>
            </div>
            
            <div class="quadrant quadrant-3">
                <div class="quadrant-title">
                    👥 DELEGATE
                    <span class="quadrant-count" id="count-3">0</span>
                </div>
                <div class="quadrant-subtitle">Not Important • Urgent</div>
                <div class="items-list" id="quadrant-3-items"></div>
                <div class="quadrant-grace-score" id="grace-3">G.R.A.C.E: 0</div>
            </div>
            
            <div class="quadrant quadrant-held">
                <div class="quadrant-title">
                    ⏸️ HELD
                    <span class="quadrant-count" id="count-held">0</span>
                </div>
                <div class="quadrant-subtitle">No Resources Available</div>
                <div class="items-list" id="quadrant-held-items"></div>
                <div class="quadrant-grace-score" id="grace-held">G.R.A.C.E: 0</div>
            </div>
            
            <div class="quadrant quadrant-completed">
                <div class="quadrant-title">
                    ✅ COMPLETED
                    <span class="quadrant-count" id="count-completed">0</span>
                </div>
                <div class="quadrant-subtitle">
                    Finished Tasks by Category
                    <button id="toggle-completed-sort" onclick="toggleCompletedSort()" style="margin-left: 10px; padding: 4px 8px; font-size: 0.7em; background: rgba(255,255,255,0.3); border: 1px solid rgba(255,255,255,0.5); border-radius: 6px; cursor: pointer; color: inherit;" title="Toggle between date and GRACE score sorting">
                        📅 Date
                    </button>
                </div>
                <div class="items-list" id="quadrant-completed-items"></div>
                <div class="quadrant-grace-score" id="grace-completed">G.R.A.C.E: 0</div>
            </div>
        </div>
        
        <div class="input-section">
            <h3>Add New Task</h3>
            <div class="input-group">
                <!-- Top row - primary fields -->
                <input type="text" id="item-title" placeholder="Task title...">
                <textarea id="item-description" placeholder="Detailed description (optional)..."></textarea>
                <select id="task-type">
                    <option value="">Select Task Type</option>
                    <option value="Church">⛪ Church</option>
                    <option value="Family">👨‍👩‍👧‍👦 Family</option>
                    <option value="Work">💼 Work</option>
                    <option value="Relationships">🤝 Relationships</option>
                    <option value="Self">🧘 Self</option>
                    <option value="Property">🏠 Property</option>
                </select>
                <select id="urgency">
                    <option value="">Select Urgency</option>
                    <option value="high">High Urgency</option>
                    <option value="low">Low Urgency</option>
                </select>
                <select id="importance">
                    <option value="">Select Importance</option>
                    <option value="high">High Importance</option>
                    <option value="low">Low Importance</option>
                </select>
            </div>
            <div class="input-group optional-fields">
                <!-- Bottom row - optional fields -->
                <input type="number" id="estimated-time" placeholder="Est. Hours" min="0.25" step="0.25" style="color: #888;">
                <input type="number" id="manual-grace-score" placeholder="Manual GRACE Score (0-100)" min="0" max="100" title="Override automatic GRACE scoring" style="color: #888;">
                <select id="recurrence" style="color: #888;">
                    <option value="">Select Recurrence</option>
                    <option value="Non-recurring">📅 Non-recurring</option>
                    <option value="Daily">🔄 Daily</option>
                    <option value="Weekly">📊 Weekly</option>
                    <option value="Monthly">🗓️ Monthly</option>
                    <option value="Quarterly">📈 Quarterly</option>
                    <option value="Annually">📆 Annually</option>
                </select>
                <select id="resources" style="color: #888;">
                    <option value="">Resources Available</option>
                    <option value="Yes">✅ Yes</option>
                    <option value="No">❌ No</option>
                </select>
            </div>
            <div class="button-group">
                <button onclick="addItem()">Add Task</button>
                <button onclick="exportData()" class="secondary-btn" title="Export as JSON with full data">📄 Export JSON</button>
                <button onclick="exportToCSV()" class="secondary-btn" title="Export as CSV for Excel/Sheets">📊 Export CSV</button>
                <button onclick="importData()" class="secondary-btn" title="Import JSON or CSV data">📥 Import Data</button>
                <button onclick="taskStorage.restoreFromBackup()" class="secondary-btn" title="Restore from automatic backup">🔄 Restore Backup</button>
                <button onclick="clearCompleted()" class="secondary-btn" title="Remove all completed tasks">🗑️ Clear Completed</button>
                <button onclick="taskStorage.clearAllData()" class="secondary-btn" title="⚠️ Delete ALL data permanently" style="background: linear-gradient(135deg, #dc3545, #c82333);">💥 Clear All Data</button>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h3>Edit Task</h3>
            <div class="input-group">
                <input type="text" id="edit-title" placeholder="Task title...">
                <textarea id="edit-description" placeholder="Detailed description..."></textarea>
                <select id="edit-task-type">
                    <option value="">Select Task Type</option>
                    <option value="Church">⛪ Church</option>
                    <option value="Family">👨‍👩‍👧‍👦 Family</option>
                    <option value="Work">💼 Work</option>
                    <option value="Relationships">🤝 Relationships</option>
                    <option value="Self">🧘 Self</option>
                    <option value="Property">🏠 Property</option>
                </select>
                <input type="number" id="edit-estimated-time" placeholder="Est. Hours" min="0.25" step="0.25">
                <input type="number" id="edit-manual-grace-score" placeholder="Manual GRACE Score (0-100)" min="0" max="100" title="Override automatic GRACE scoring">
                <select id="edit-recurrence">
                    <option value="">Select Recurrence</option>
                    <option value="Non-recurring">📅 Non-recurring</option>
                    <option value="Daily">🔄 Daily</option>
                    <option value="Weekly">📊 Weekly</option>
                    <option value="Monthly">🗓️ Monthly</option>
                    <option value="Quarterly">📈 Quarterly</option>
                    <option value="Annually">📆 Annually</option>
                </select>
                <select id="edit-resources">
                    <option value="">Resources Available?</option>
                    <option value="Yes">✅ Yes</option>
                    <option value="No">❌ No</option>
                </select>
                <select id="edit-urgency">
                    <option value="">Select Urgency</option>
                    <option value="high">High Urgency</option>
                    <option value="low">Low Urgency</option>
                </select>
                <select id="edit-importance">
                    <option value="">Select Importance</option>
                    <option value="high">High Importance</option>
                    <option value="low">Low Importance</option>
                </select>
            </div>
            <div class="button-group">
                <button onclick="saveEdit()">Save Changes</button>
                <button onclick="closeEditModal()" class="secondary-btn">Cancel</button>
            </div>
        </div>
    </div>

    <input type="file" id="import-file" accept=".json,.csv" style="display: none;">

    <script>
        // Enhanced storage system using IndexedDB for persistence
        let taskStorage = {
            tasks: [],
            nextId: 1,
            db: null,
            dbName: 'GRACEMatrix',
            dbVersion: 1,
            completedSortByGrace: false, // Default to date sorting (most recent first)
            
            async init() {
                try {
                    await this.openDatabase();
                    await this.loadFromIndexedDB();
                    this.updateStats();
                    this.renderAllTasks();
                    // Auto-backup every 5 minutes
                    setInterval(() => this.autoBackup(), 5 * 60 * 1000);
                } catch (error) {
                    console.error('Database initialization failed, falling back to memory storage:', error);
                    this.showNotification('⚠️ Using temporary storage - data will not persist', 'error');
                }
            },
            
            async openDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => {
                        reject(new Error('Failed to open database'));
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create tasks store
                        if (!db.objectStoreNames.contains('tasks')) {
                            const tasksStore = db.createObjectStore('tasks', { keyPath: 'id' });
                            tasksStore.createIndex('quadrant', 'quadrant', { unique: false });
                            tasksStore.createIndex('graceScore', 'graceScore', { unique: false });
                            tasksStore.createIndex('completed', 'completed', { unique: false });
                            tasksStore.createIndex('createdAt', 'createdAt', { unique: false });
                        }
                        
                        // Create metadata store
                        if (!db.objectStoreNames.contains('metadata')) {
                            db.createObjectStore('metadata', { keyPath: 'key' });
                        }
                    };
                });
            },
            
            async loadFromIndexedDB() {
                if (!this.db) return;
                
                try {
                    // Load tasks
                    const tasksTransaction = this.db.transaction(['tasks'], 'readonly');
                    const tasksStore = tasksTransaction.objectStore('tasks');
                    const tasksRequest = tasksStore.getAll();
                    
                    tasksRequest.onsuccess = (event) => {
                        this.tasks = event.target.result || [];
                        
                        // Set nextId to highest existing ID + 1
                        if (this.tasks.length > 0) {
                            this.nextId = Math.max(...this.tasks.map(t => t.id)) + 1;
                        }
                        
                        this.updateStats();
                        this.renderAllTasks();
                    };
                    
                    // Load metadata (like nextId)
                    const metaTransaction = this.db.transaction(['metadata'], 'readonly');
                    const metaStore = metaTransaction.objectStore('metadata');
                    const metaRequest = metaStore.get('nextId');
                    
                    metaRequest.onsuccess = (event) => {
                        if (event.target.result) {
                            this.nextId = event.target.result.value;
                        }
                    };
                    
                } catch (error) {
                    console.error('Failed to load from IndexedDB:', error);
                    this.showNotification('⚠️ Failed to load saved data', 'error');
                }
            },
            
            async saveToIndexedDB() {
                if (!this.db) return;
                
                try {
                    // Save all tasks
                    const transaction = this.db.transaction(['tasks', 'metadata'], 'readwrite');
                    const tasksStore = transaction.objectStore('tasks');
                    const metaStore = transaction.objectStore('metadata');
                    
                    // Clear existing tasks and add current ones
                    await tasksStore.clear();
                    for (const task of this.tasks) {
                        await tasksStore.add(task);
                    }
                    
                    // Save metadata
                    await metaStore.put({ key: 'nextId', value: this.nextId });
                    await metaStore.put({ key: 'lastSaved', value: new Date().toISOString() });
                    
                    return new Promise((resolve) => {
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = () => {
                            console.error('Transaction failed');
                            resolve();
                        };
                    });
                    
                } catch (error) {
                    console.error('Failed to save to IndexedDB:', error);
                    this.showNotification('⚠️ Failed to save data', 'error');
                }
            },
            
            async save() {
                await this.saveToIndexedDB();
                this.updateStats();
                this.renderAllTasks();
            },
            
            load() {
                // This method kept for compatibility, but init() handles loading
                this.init();
            },
            
            async addTask(task) {
                task.id = this.nextId++;
                task.createdAt = new Date().toISOString();
                task.completed = false;
                task.completedAt = null;
                task.performanceScore = null; // For recurring tasks
                task.isScheduled = false; // For tracking external scheduling
                this.tasks.push(task);
                await this.save();
            },
            
            async updateTask(id, updates) {
                const taskIndex = this.tasks.findIndex(t => t.id === id);
                if (taskIndex !== -1) {
                    this.tasks[taskIndex] = { ...this.tasks[taskIndex], ...updates };
                    await this.save();
                    return true;
                }
                return false;
            },
            
            async deleteTask(id) {
                this.tasks = this.tasks.filter(t => t.id !== id);
                await this.save();
            },
            
            async toggleComplete(id) {
                const task = this.tasks.find(t => t.id === id);
                if (task) {
                    task.completed = !task.completed;
                    task.completedAt = task.completed ? new Date().toISOString() : null;
                    await this.save();
                }
            },
            
            async autoBackup() {
                try {
                    const backupData = {
                        version: '2.0',
                        exportDate: new Date().toISOString(),
                        tasks: this.tasks,
                        metadata: {
                            totalTasks: this.tasks.length,
                            completedTasks: this.tasks.filter(t => t.completed).length,
                            avgGraceScore: this.tasks.length > 0 
                                ? (this.tasks.reduce((sum, t) => sum + t.graceScore, 0) / this.tasks.length).toFixed(1)
                                : 0.0
                        }
                    };
                    
                    // Store backup in localStorage as fallback
                    localStorage.setItem('graceMatrixBackup', JSON.stringify(backupData));
                    localStorage.setItem('graceMatrixBackupTime', new Date().toISOString());
                    
                } catch (error) {
                    console.warn('Auto-backup failed:', error);
                }
            },
            
            async restoreFromBackup() {
                try {
                    const backup = localStorage.getItem('graceMatrixBackup');
                    if (backup) {
                        const backupData = JSON.parse(backup);
                        const backupTime = localStorage.getItem('graceMatrixBackupTime');
                        
                        if (confirm(`Restore from backup created on ${new Date(backupTime).toLocaleString()}?\n\nThis will replace all current data.`)) {
                            this.tasks = backupData.tasks || [];
                            if (this.tasks.length > 0) {
                                this.nextId = Math.max(...this.tasks.map(t => t.id)) + 1;
                            }
                            await this.save();
                            this.showNotification('✅ Data restored from backup!', 'success');
                        }
                    } else {
                        this.showNotification('❌ No backup found', 'error');
                    }
                } catch (error) {
                    console.error('Restore failed:', error);
                    this.showNotification('❌ Restore failed', 'error');
                }
            },
            
            async clearAllData() {
                if (confirm('⚠️ WARNING: This will permanently delete ALL your tasks and data.\n\nThis cannot be undone. Are you absolutely sure?')) {
                    try {
                        // Clear IndexedDB
                        if (this.db) {
                            const transaction = this.db.transaction(['tasks', 'metadata'], 'readwrite');
                            await transaction.objectStore('tasks').clear();
                            await transaction.objectStore('metadata').clear();
                        }
                        
                        // Clear memory
                        this.tasks = [];
                        this.nextId = 1;
                        
                        // Clear localStorage backup
                        localStorage.removeItem('graceMatrixBackup');
                        localStorage.removeItem('graceMatrixBackupTime');
                        
                        this.updateStats();
                        this.renderAllTasks();
                        
                        this.showNotification('🗑️ All data cleared', 'info');
                    } catch (error) {
                        console.error('Clear data failed:', error);
                        this.showNotification('❌ Failed to clear data', 'error');
                    }
                }
            },
            
            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 20px;
                    border-radius: 10px;
                    color: white;
                    font-weight: 600;
                    z-index: 1001;
                    transform: translateX(100%);
                    transition: transform 0.3s ease;
                    box-shadow: 0 10px 20px rgba(0,0,0,0.2);
                    max-width: 300px;
                    ${type === 'success' ? 'background: linear-gradient(135deg, #28a745, #20c997);' : 
                      type === 'error' ? 'background: linear-gradient(135deg, #dc3545, #fd7e14);' : 
                      'background: linear-gradient(135deg, #667eea, #764ba2);'}
                `;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                // Animate in
                setTimeout(() => {
                    notification.style.transform = 'translateX(0)';
                }, 100);
                
                // Animate out and remove
                setTimeout(() => {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            document.body.removeChild(notification);
                        }
                    }, 300);
                }, type === 'error' ? 5000 : 3000); // Error messages stay longer
            },
            
            updateStats() {
                // Apply current filters to get filtered tasks
                const taskTypeFilter = document.getElementById('filter-task-type')?.value || '';
                const recurrenceFilter = document.getElementById('filter-recurrence')?.value || '';
                
                let filteredTasks = [...this.tasks];
                
                if (taskTypeFilter) {
                    filteredTasks = filteredTasks.filter(task => task.taskType === taskTypeFilter);
                }
                
                if (recurrenceFilter) {
                    filteredTasks = filteredTasks.filter(task => task.recurrence === recurrenceFilter);
                }
                
                // Calculate stats based on filtered tasks
                const totalTasks = filteredTasks.length;
                const totalHours = filteredTasks.reduce((sum, t) => sum + (parseFloat(t.estimatedTime) || 0), 0);
                
                // Calculate combined GRACE score for important tasks (Do Now + Schedule)
                const importantTasks = filteredTasks.filter(task => 
                    !task.completed && (task.quadrant === 1 || task.quadrant === 2)
                );
                
                const combinedGrace = importantTasks.length > 0 
                    ? (importantTasks.reduce((sum, t) => sum + (t.graceScore || 0), 0) / importantTasks.length).toFixed(0)
                    : 0;
                
                // Update stats display
                document.getElementById('total-tasks').textContent = totalTasks;
                document.getElementById('total-hours').textContent = totalHours.toFixed(1);
                document.getElementById('combined-grace').textContent = combinedGrace;
                
                // Update progress bar based on all tasks (not filtered)
                const allTasks = this.tasks.length;
                const allCompleted = this.tasks.filter(t => t.completed).length;
                const progressPercent = allTasks > 0 ? (allCompleted / allTasks) * 100 : 0;
                document.getElementById('completion-progress').style.width = progressPercent + '%';
                
                // Update pie chart (always uses unfiltered data)
                this.updatePieChart();
            },
            
            updatePieChart() {
                // Calculate weekly hours for non-recurring, daily, and weekly tasks from important quadrants
                const relevantTasks = this.tasks.filter(task => 
                    !task.completed && 
                    (task.quadrant === 1 || task.quadrant === 2) &&
                    ['Non-recurring', 'Daily', 'Weekly'].includes(task.recurrence)
                );
                
                const weeklyHoursByCategory = {
                    'Church': 0, 'Family': 0, 'Work': 0, 
                    'Relationships': 0, 'Self': 0, 'Property': 0
                };
                
                // Calculate weekly hours by category
                relevantTasks.forEach(task => {
                    if (weeklyHoursByCategory.hasOwnProperty(task.taskType)) {
                        const taskHours = parseFloat(task.estimatedTime) || 0;
                        let weeklyHours = 0;
                        
                        switch(task.recurrence) {
                            case 'Daily': weeklyHours = taskHours * 7; break;
                            case 'Weekly': weeklyHours = taskHours; break;
                            case 'Non-recurring': weeklyHours = taskHours; break;
                        }
                        
                        weeklyHoursByCategory[task.taskType] += weeklyHours;
                    }
                });
                
                const totalPlannedHours = Object.values(weeklyHoursByCategory).reduce((sum, hours) => sum + hours, 0);
                const totalWeekHours = 168;
                const unutilizedHours = Math.max(0, totalWeekHours - totalPlannedHours);
                
                // Update unutilized time display
                const unutilizedPercentage = (unutilizedHours / totalWeekHours) * 100;
                document.getElementById('unutilized-percentage').textContent = `${unutilizedPercentage.toFixed(1)}%`;
                document.getElementById('unutilized-hours').textContent = `${unutilizedHours.toFixed(1)} hrs`;
                
                // Always generate charts with unutilized time
                this.renderPieCharts({ ...weeklyHoursByCategory, 'Unutilized Time': unutilizedHours }, totalWeekHours);
            },
            
            renderPieCharts(hoursData, totalWeekHours) {
                const chartConfig = {
                    colors: {
                        'Church': '#8e44ad', 'Family': '#e74c3c', 'Work': '#3498db',
                        'Relationships': '#f39c12', 'Self': '#27ae60', 'Property': '#95a5a6',
                        'Unutilized Time': '#bdc3c7'
                    },
                    icons: {
                        'Church': '⛪', 'Family': '👨‍👩‍👧‍👦', 'Work': '💼',
                        'Relationships': '🤝', 'Self': '🧘', 'Property': '🏠',
                        'Unutilized Time': '⏰'
                    },
                    dimensions: {
                        viewBox: '0 0 400 280',
                        radius: 90,
                        centerX: 200,
                        centerY: 140,
                        lineLength: 60
                    }
                };
                
                // Create both SVG charts
                const charts = ['percentage', 'hours'].map(type => {
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('viewBox', chartConfig.dimensions.viewBox);
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    return { type, svg };
                });
                
                // Filter visible data and create chart elements
                const visibleData = Object.entries(hoursData).filter(([_, hours]) => hours > 0);
                if (visibleData.length === 0) visibleData.push(['Unutilized Time', 168]);
                
                let currentAngle = 0;
                let sharedLegendHTML = '';
                
                visibleData.forEach(([category, hours]) => {
                    const percentage = (hours / totalWeekHours) * 100;
                    const angle = (hours / totalWeekHours) * 360;
                    const color = chartConfig.colors[category];
                    const icon = chartConfig.icons[category];
                    
                    // Create pie slices and labels for both charts
                    charts.forEach(({ type, svg }) => {
                        const slice = this.createPieSlice(
                            chartConfig.dimensions.centerX, 
                            chartConfig.dimensions.centerY, 
                            chartConfig.dimensions.radius, 
                            currentAngle, 
                            currentAngle + angle, 
                            color
                        );
                        svg.appendChild(slice);
                        
                        // Add horizontal leader line and label
                        const { line, text } = this.createHorizontalLabel(
                            chartConfig.dimensions,
                            currentAngle + (angle / 2),
                            color,
                            type === 'percentage' ? `${percentage.toFixed(1)}%` : `${hours.toFixed(1)}h`
                        );
                        svg.appendChild(line);
                        svg.appendChild(text);
                    });
                    
                    // Build single shared legend entry
                    sharedLegendHTML += `
                        <div class="legend-entry">
                            <div class="legend-color-dot" style="background-color: ${color}"></div>
                            <div class="legend-text">${icon} ${category}: ${percentage.toFixed(1)}% (${hours.toFixed(1)}h)</div>
                        </div>
                    `;
                    
                    currentAngle += angle;
                });
                
                // Update DOM with single legend
                this.updateChartDOM(charts, sharedLegendHTML);
            },
            
            createHorizontalLabel(dimensions, sliceAngle, color, text) {
                const { centerX, centerY, radius, lineLength } = dimensions;
                const sliceAngleRad = (sliceAngle * Math.PI) / 180;
                
                // Calculate line start point (edge of pie)
                const startX = centerX + radius * Math.cos(sliceAngleRad);
                const startY = centerY + radius * Math.sin(sliceAngleRad);
                
                // Create horizontal line (left or right based on position)
                const isRightSide = startX >= centerX;
                const lineEndX = isRightSide ? startX + lineLength : startX - lineLength;
                
                // Create line element
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX);
                line.setAttribute('y1', startY);
                line.setAttribute('x2', lineEndX);
                line.setAttribute('y2', startY); // Same Y for horizontal line
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', '2');
                
                // Create text element
                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textElement.setAttribute('x', lineEndX);
                textElement.setAttribute('y', startY);
                textElement.setAttribute('text-anchor', isRightSide ? 'start' : 'end');
                textElement.setAttribute('dominant-baseline', 'central');
                textElement.setAttribute('fill', color);
                textElement.setAttribute('font-size', '14');
                textElement.setAttribute('font-weight', 'bold');
                textElement.textContent = text;
                
                return { line, text: textElement };
            },
            
            updateChartDOM(charts, sharedLegendHTML) {
                const containers = {
                    percentage: document.getElementById('percentage-chart-container'),
                    hours: document.getElementById('hours-chart-container')
                };
                
                charts.forEach(({ type, svg }) => {
                    if (containers[type]) {
                        containers[type].innerHTML = '';
                        containers[type].appendChild(svg);
                    }
                });
                
                // Update the single shared legend
                const sharedLegend = document.getElementById('shared-legend');
                if (sharedLegend) {
                    sharedLegend.innerHTML = sharedLegendHTML;
                }
            },
            
            createPieSlice(centerX, centerY, radius, startAngle, endAngle, color) {
                // Handle full circle case (360 degrees)
                if (endAngle - startAngle >= 360) {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', centerX);
                    circle.setAttribute('cy', centerY);
                    circle.setAttribute('r', radius);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('class', 'pie-slice');
                    circle.setAttribute('stroke', 'white');
                    circle.setAttribute('stroke-width', '2');
                    return circle;
                }
                
                const startAngleRad = (startAngle * Math.PI) / 180;
                const endAngleRad = (endAngle * Math.PI) / 180;
                
                const x1 = centerX + radius * Math.cos(startAngleRad);
                const y1 = centerY + radius * Math.sin(startAngleRad);
                const x2 = centerX + radius * Math.cos(endAngleRad);
                const y2 = centerY + radius * Math.sin(endAngleRad);
                
                const largeArcFlag = endAngle - startAngle > 180 ? 1 : 0;
                
                const pathData = `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('fill', color);
                path.setAttribute('class', 'pie-slice');
                path.setAttribute('stroke', 'white');
                path.setAttribute('stroke-width', '2');
                
                // Add hover effect with title
                const percentage = ((endAngle - startAngle) / 360 * 100).toFixed(1);
                path.setAttribute('title', `${percentage}%`);
                
                return path;
            },
            
            renderAllTasks() {
                // Clear all quadrants
                ['1', '2', '3', '4', 'held', 'completed'].forEach(quadrant => {
                    document.getElementById(`quadrant-${quadrant}-items`).innerHTML = '';
                });
                
                // Apply filters
                const taskTypeFilter = document.getElementById('filter-task-type').value;
                const recurrenceFilter = document.getElementById('filter-recurrence').value;
                
                // Filter tasks based on selected filters
                let filteredTasks = [...this.tasks];
                
                if (taskTypeFilter) {
                    filteredTasks = filteredTasks.filter(task => task.taskType === taskTypeFilter);
                }
                
                if (recurrenceFilter) {
                    filteredTasks = filteredTasks.filter(task => task.recurrence === recurrenceFilter);
                }
                
                // Separate completed and non-completed tasks
                const activeTasks = filteredTasks.filter(task => !task.completed);
                const completedTasks = filteredTasks.filter(task => task.completed);
                
                // Sort active tasks by GRACE score (highest first) and render
                const sortedActiveTasks = activeTasks.sort((a, b) => b.graceScore - a.graceScore);
                
                sortedActiveTasks.forEach(task => {
                    this.renderTask(task);
                });
                
                // Render completed tasks with special organization
                this.renderCompletedTasks(completedTasks);
                
                // Update quadrant counts with filtered data (excluding completed from active counts)
                this.updateQuadrantCounts(filteredTasks);
            },
            
            renderCompletedTasks(completedTasks) {
                const container = document.getElementById('quadrant-completed-items');
                
                if (completedTasks.length === 0) {
                    container.innerHTML = '<div style="text-align: center; opacity: 0.7; padding: 20px;">No completed tasks yet</div>';
                    return;
                }
                
                // Group completed tasks by task type
                const tasksByType = {};
                completedTasks.forEach(task => {
                    if (!tasksByType[task.taskType]) {
                        tasksByType[task.taskType] = [];
                    }
                    tasksByType[task.taskType].push(task);
                });
                
                // Sort each group by completion date (most recent first) or GRACE score (highest first)
                Object.keys(tasksByType).forEach(taskType => {
                    if (this.completedSortByGrace) {
                        tasksByType[taskType].sort((a, b) => b.graceScore - a.graceScore);
                    } else {
                        // Sort by completion date (most recent first)
                        tasksByType[taskType].sort((a, b) => {
                            const dateA = new Date(a.completedAt || 0);
                            const dateB = new Date(b.completedAt || 0);
                            return dateB - dateA; // Most recent first
                        });
                    }
                });
                
                // Define task type order for consistent display
                const taskTypeOrder = ['Church', 'Family', 'Self', 'Relationships', 'Work', 'Property'];
                
                // Render each task type section
                taskTypeOrder.forEach(taskType => {
                    if (tasksByType[taskType]) {
                        const tasks = tasksByType[taskType];
                        const avgGrace = (tasks.reduce((sum, t) => sum + t.graceScore, 0) / tasks.length).toFixed(1);
                        
                        // Create task type section
                        const typeSection = document.createElement('div');
                        typeSection.className = 'task-type-section';
                        
                        // Create header with average GRACE score and sort indicator
                        const header = document.createElement('div');
                        header.className = 'task-type-header';
                        header.innerHTML = `
                            <span>${getTaskTypeIcon(taskType)} ${taskType}</span>
                            <span class="grace-average">
                                ${this.completedSortByGrace ? `Avg: ${avgGrace}` : `${tasks.length} tasks`}
                            </span>
                        `;
                        typeSection.appendChild(header);
                        
                        // Create tasks container for this type
                        const tasksContainer = document.createElement('div');
                        tasksContainer.style.cssText = 'display: flex; flex-direction: column; gap: 4px;';
                        
                        // Render tasks for this type
                        tasks.forEach(task => {
                            const itemDiv = this.createCompletedTaskElement(task);
                            tasksContainer.appendChild(itemDiv);
                        });
                        
                        typeSection.appendChild(tasksContainer);
                        container.appendChild(typeSection);
                    }
                });
            },
            
            createCompletedTaskElement(task) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'item completed';
                itemDiv.dataset.taskId = task.id;
                itemDiv.onclick = () => openEditModal(task.id);
                
                // Check if task is recurring for performance circle
                const isRecurring = task.recurrence !== 'Non-recurring';
                
                // Build task content for completed tasks
                let performanceControl = '';
                if (isRecurring && task.performanceScore !== null && task.performanceScore !== undefined) {
                    const score = task.performanceScore;
                    let circleClass = 'no-score';
                    let displayText = '?';
                    
                    if (score !== null && score !== undefined) {
                        displayText = Math.round(score);
                        if (score < 50) {
                            circleClass = 'low-score';
                        } else if (score < 85) {
                            circleClass = 'mid-score';
                        } else {
                            circleClass = 'high-score';
                        }
                    }
                    
                    performanceControl = `
                        <div class="performance-circle ${circleClass}" 
                             title="Final Performance: ${score || 'No score'}%">
                            ${displayText}
                        </div>
                    `;
                }
                
                // Completed date for display
                const completedDate = task.completedAt ? new Date(task.completedAt).toLocaleDateString() : '';
                
                // Layout for completed tasks - using same classes as active tasks
                itemDiv.innerHTML = `
                    <div class="item-content">
                        <div class="item-title-text">${task.title}</div>
                        <div class="item-details">
                            <span class="item-duration">${task.estimatedTime}h</span>
                            <span class="item-recurrence">${task.recurrence}</span>
                            <span style="background: rgba(255,255,255,0.3); padding: 2px 6px; border-radius: 4px; font-weight: 500;" class="item-duration">${task.graceScore}</span>
                            ${completedDate ? `<span style="background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 4px;" class="item-duration">${completedDate}</span>` : ''}
                        </div>
                    </div>
                    <div class="item-controls-row">
                        ${performanceControl}
                        <input type="checkbox" 
                               class="completion-checkbox" 
                               checked 
                               onclick="event.stopPropagation(); taskStorage.toggleComplete(${task.id})"
                               title="Mark as incomplete">
                        <button class="delete-btn" onclick="deleteTask(${task.id}, event)" title="Delete task">×</button>
                    </div>
                `;
                
                return itemDiv;
            },
            
            updateQuadrantCounts(tasksToCount = null) {
                const tasks = tasksToCount || this.tasks;
                const quadrantCounts = { 1: 0, 2: 0, 3: 0, 4: 0, held: 0, completed: 0 };
                const quadrantGraceScores = { 1: [], 2: [], 3: [], 4: [], held: [], completed: [] };
                const schedulePerformanceScores = [];
                
                tasks.forEach(task => {
                    if (task.completed) {
                        quadrantCounts.completed++;
                        quadrantGraceScores.completed.push(task.graceScore || 0);
                    } else {
                        quadrantCounts[task.quadrant]++;
                        quadrantGraceScores[task.quadrant].push(task.graceScore || 0);
                        
                        // Collect performance scores for Schedule quadrant
                        if (task.quadrant === 2 && task.performanceScore !== null && task.performanceScore !== undefined) {
                            schedulePerformanceScores.push(parseFloat(task.performanceScore));
                        }
                    }
                });
                
                // Update counts
                Object.keys(quadrantCounts).forEach(quadrant => {
                    const element = document.getElementById(`count-${quadrant}`);
                    if (element) {
                        element.textContent = quadrantCounts[quadrant];
                    }
                });
                
                // Update average GRACE scores
                Object.keys(quadrantGraceScores).forEach(quadrant => {
                    const element = document.getElementById(`grace-${quadrant}`);
                    if (element) {
                        const scores = quadrantGraceScores[quadrant];
                        if (scores.length > 0) {
                            const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
                            element.textContent = `G.R.A.C.E: ${avgScore.toFixed(0)}`;
                        } else {
                            element.textContent = 'G.R.A.C.E: 0';
                        }
                    }
                });
                
                // Update average performance score for Schedule quadrant
                const performanceElement = document.getElementById('performance-2');
                if (performanceElement) {
                    if (schedulePerformanceScores.length > 0) {
                        const avgPerformance = schedulePerformanceScores.reduce((sum, score) => sum + score, 0) / schedulePerformanceScores.length;
                        performanceElement.textContent = `Perf: ${avgPerformance.toFixed(0)}%`;
                    } else {
                        performanceElement.textContent = 'Perf: 0%';
                    }
                }
            },
            
            renderTask(task) {
                // Skip completed tasks here - they're handled by renderCompletedTasks
                if (task.completed) return;
                
                const quadrantId = `quadrant-${task.quadrant}-items`;
                const container = document.getElementById(quadrantId);
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'item';
                itemDiv.dataset.taskId = task.id;
                itemDiv.onclick = () => openEditModal(task.id);
                
                // Check if task is recurring (not "Non-recurring")
                const isRecurring = task.recurrence !== 'Non-recurring';
                
                // Build task content with all attributes in one row
                let scheduledControl = '';
                let performanceControl = '';
                let completionControl = '';
                
                // Add scheduled checkbox for recurring tasks
                if (isRecurring) {
                    scheduledControl = `
                        <div style="display: flex; align-items: center; gap: 2px;">
                            <input type="checkbox" 
                                   class="scheduled-checkbox" 
                                   ${task.isScheduled ? 'checked' : ''} 
                                   onclick="event.stopPropagation(); toggleScheduled(${task.id})"
                                   title="Scheduled externally">
                            <span class="scheduled-label">Sched</span>
                        </div>
                    `;
                    
                    // Add performance circle for recurring tasks
                    const score = task.performanceScore;
                    let circleClass = 'no-score';
                    let displayText = '?';
                    
                    if (score !== null && score !== undefined) {
                        displayText = Math.round(score);
                        if (score < 50) {
                            circleClass = 'low-score';
                        } else if (score < 85) {
                            circleClass = 'mid-score';
                        } else {
                            circleClass = 'high-score';
                        }
                    }
                    
                    performanceControl = `
                        <div class="performance-circle ${circleClass}" 
                             onclick="event.stopPropagation(); openPerformanceModal(${task.id})" 
                             title="Performance: ${score || 'No score'}">
                            ${displayText}
                        </div>
                    `;
                }
                
                // Completion control for all active tasks
                completionControl = `
                    <input type="checkbox" 
                           class="completion-checkbox" 
                           onclick="event.stopPropagation(); taskStorage.toggleComplete(${task.id})"
                           title="Mark complete">
                `;
                
                // Single row layout with all attributes
                itemDiv.innerHTML = `
                    <div class="item-content">
                        <div class="item-title-text">${task.title}</div>
                        <div class="item-details">
                            <span>${getTaskTypeIcon(task.taskType)}</span>
                            <span class="item-duration">${task.estimatedTime}h</span>
                            <span class="item-recurrence">${task.recurrence}</span>
                            <span style="background: rgba(255,255,255,0.3); padding: 2px 6px; border-radius: 4px; font-weight: 500;">${task.graceScore}</span>
                        </div>
                    </div>
                    <div class="item-controls-row">
                        ${scheduledControl}
                        ${performanceControl}
                        ${completionControl}
                        <button class="delete-btn" onclick="event.stopPropagation(); deleteTask(${task.id})" title="Delete task">×</button>
                    </div>
                `;
                
                container.appendChild(itemDiv);
            }
        };
        
        function getTaskTypeIcon(taskType) {
            const icons = {
                'Church': '⛪',
                'Family': '👨‍👩‍👧‍👦',
                'Work': '💼',
                'Relationships': '🤝',
                'Self': '🧘',
                'Property': '🏠'
            };
            return icons[taskType] || '📋';
        }
        
        let currentEditingId = null;
        
        function openEditModal(taskId) {
            const task = taskStorage.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            currentEditingId = taskId;
            
            // Populate modal fields
            document.getElementById('edit-title').value = task.title;
            document.getElementById('edit-description').value = task.description || '';
            document.getElementById('edit-task-type').value = task.taskType;
            document.getElementById('edit-estimated-time').value = task.estimatedTime;
            document.getElementById('edit-manual-grace-score').value = task.manualGraceScore || '';
            document.getElementById('edit-recurrence').value = task.recurrence;
            document.getElementById('edit-resources').value = task.resources;
            document.getElementById('edit-urgency').value = task.urgency;
            document.getElementById('edit-importance').value = task.importance;
            
            document.getElementById('editModal').style.display = 'block';
        }
        
        function closeEditModal() {
            document.getElementById('editModal').style.display = 'none';
            currentEditingId = null;
        }
        
        function saveEdit() {
            if (!currentEditingId) return;
            
            const updates = {
                title: document.getElementById('edit-title').value,
                description: document.getElementById('edit-description').value,
                taskType: document.getElementById('edit-task-type').value,
                estimatedTime: document.getElementById('edit-estimated-time').value,
                recurrence: document.getElementById('edit-recurrence').value,
                resources: document.getElementById('edit-resources').value,
                urgency: document.getElementById('edit-urgency').value,
                importance: document.getElementById('edit-importance').value
            };
            
            const manualGraceScore = document.getElementById('edit-manual-grace-score').value;
            const manualScore = manualGraceScore ? parseInt(manualGraceScore) : null;
            
            if (!updates.title || !updates.taskType || !updates.estimatedTime || 
                !updates.recurrence || !updates.resources || !updates.urgency || !updates.importance) {
                alert('Please fill in all required fields');
                return;
            }
            
            // Validate manual GRACE score if provided
            if (manualScore !== null && (manualScore < 0 || manualScore > 100)) {
                alert('Manual GRACE score must be between 0 and 100');
                document.getElementById('edit-manual-grace-score').focus();
                return;
            }
            
            // Recalculate quadrant and GRACE score
            updates.quadrant = determineQuadrant(updates.urgency, updates.importance, updates.resources);
            updates.graceScore = calculateGraceScore(updates.title, updates.description || '', updates.taskType, manualScore, updates.estimatedTime, updates.recurrence);
            updates.manualGraceScore = manualScore;
            
            taskStorage.updateTask(currentEditingId, updates);
            closeEditModal();
            
            // Show success message
            showNotification('✅ Task updated successfully!', 'success');
        }
        
        function toggleCompletedSort() {
            taskStorage.completedSortByGrace = !taskStorage.completedSortByGrace;
            
            // Update button text and icon
            const button = document.getElementById('toggle-completed-sort');
            if (taskStorage.completedSortByGrace) {
                button.innerHTML = '🏆 GRACE';
                button.title = 'Currently sorting by GRACE score (highest first). Click to sort by completion date.';
            } else {
                button.innerHTML = '📅 Date';
                button.title = 'Currently sorting by completion date (most recent first). Click to sort by GRACE score.';
            }
            
            // Re-render completed tasks with new sorting
            taskStorage.renderAllTasks();
            
            // Show notification
            const sortType = taskStorage.completedSortByGrace ? 'GRACE score (highest first)' : 'completion date (most recent first)';
            taskStorage.showNotification(`📋 Completed tasks sorted by ${sortType}`, 'info');
        }
        
        function deleteTask(taskId, event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }
            
            // Create custom confirmation modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 2000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                text-align: center;
                max-width: 400px;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #2c3e50;">Delete Task</h3>
                <p style="color: #666; margin: 20px 0;">Are you sure you want to delete this task? This action cannot be undone.</p>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button id="confirm-delete" style="background: linear-gradient(135deg, #dc3545, #c82333); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 600;">Delete</button>
                    <button id="cancel-delete" style="background: linear-gradient(135deg, #6c757d, #495057); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 600;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            // Handle confirm
            document.getElementById('confirm-delete').onclick = () => {
                document.body.removeChild(modal);
                taskStorage.deleteTask(taskId);
                taskStorage.showNotification('🗑️ Task deleted successfully!', 'info');
            };
            
            // Handle cancel
            document.getElementById('cancel-delete').onclick = () => {
                document.body.removeChild(modal);
            };
            
            // Handle click outside modal
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
        }
        
        function addItem() {
            const title = document.getElementById('item-title').value.trim();
            const description = document.getElementById('item-description').value.trim();
            const taskType = document.getElementById('task-type').value;
            const estimatedTime = document.getElementById('estimated-time').value || '1'; // Default to 1 hour
            const manualGraceScore = document.getElementById('manual-grace-score').value;
            const recurrence = document.getElementById('recurrence').value || 'Non-recurring'; // Default to non-recurring
            const resources = document.getElementById('resources').value || 'Yes'; // Default to "Yes" if empty
            const urgency = document.getElementById('urgency').value;
            const importance = document.getElementById('importance').value;
            
            // Validate required fields (only the primary ones)
            if (!title) {
                alert('Please enter a task title');
                document.getElementById('item-title').focus();
                return;
            }
            
            if (!taskType) {
                alert('Please select a task type');
                document.getElementById('task-type').focus();
                return;
            }
            
            if (!urgency) {
                alert('Please select urgency level');
                document.getElementById('urgency').focus();
                return;
            }
            
            if (!importance) {
                alert('Please select importance level');
                document.getElementById('importance').focus();
                return;
            }
            
            // Validate optional fields only if they're provided
            if (estimatedTime && estimatedTime <= 0) {
                alert('Estimated hours must be greater than 0');
                document.getElementById('estimated-time').focus();
                return;
            }
            
            // Validate manual GRACE score if provided
            const manualScore = manualGraceScore ? parseInt(manualGraceScore) : null;
            if (manualScore !== null && (manualScore < 0 || manualScore > 100)) {
                alert('Manual GRACE score must be between 0 and 100');
                document.getElementById('manual-grace-score').focus();
                return;
            }
            
            const task = {
                title,
                description,
                taskType,
                estimatedTime: parseFloat(estimatedTime),
                recurrence,
                resources,
                urgency,
                importance,
                quadrant: determineQuadrant(urgency, importance, resources),
                graceScore: calculateGraceScore(title, description, taskType, manualScore, estimatedTime, recurrence),
                manualGraceScore: manualScore
            };
            
            taskStorage.addTask(task);
            clearForm();
            
            // Show success message with GRACE score explanation
            const autoScore = calculateGraceScore(title, description, taskType, null, estimatedTime, recurrence);
            const finalScore = task.graceScore;
            let message = `✅ Task added successfully! GRACE Score: ${finalScore}/100`;
            
            if (manualScore !== null) {
                message += ` (Manual Override: ${manualScore}, Auto: ${autoScore})`;
            } else if (taskType === 'Self' && ['sleep', 'rest', 'exercise', 'workout', 'health'].some(keyword => title.toLowerCase().includes(keyword))) {
                message += ` (Self-care foundation recognized!)`;
            }
            
            showNotification(message, 'success');
        }
        
        function clearForm() {
            document.getElementById('item-title').value = '';
            document.getElementById('item-description').value = '';
            document.getElementById('task-type').value = '';
            document.getElementById('estimated-time').value = '';
            document.getElementById('manual-grace-score').value = '';
            document.getElementById('recurrence').value = '';
            document.getElementById('resources').value = ''; // Reset to empty (which defaults to Yes)
            document.getElementById('urgency').value = '';
            document.getElementById('importance').value = '';
        }
        
        function determineQuadrant(urgency, importance, resources) {
            if (resources === 'No') {
                return 'held';
            }
            
            if (urgency === 'high' && importance === 'high') return 1;
            if (urgency === 'low' && importance === 'high') return 2;
            if (urgency === 'high' && importance === 'low') return 3;
            return 4;
        }
        
        // Enhanced GRACE scoring algorithm with weighted priorities and task type hierarchy
        function calculateGraceScore(title, description, taskType, manualOverride = null, estimatedTime = 0, recurrence = '') {
            // If manual override is provided, use it
            if (manualOverride !== null && manualOverride >= 0 && manualOverride <= 100) {
                return manualOverride;
            }
            
            const text = (title + ' ' + (description || '')).toLowerCase();
            const hours = parseFloat(estimatedTime) || 0;
            let totalScore = 0;
            const breakdown = { G: 0, R: 0, A: 0, C: 0, E: 0 };
            
            // Task Type Hierarchy Multipliers (Church highest, Property lowest)
            const taskTypeMultipliers = {
                'Church': 1.0,      // Highest - no reduction
                'Family': 0.9,      // Second highest  
                'Self': 0.8,        // Third
                'Relationships': 0.7, // Fourth
                'Work': 0.6,        // Fifth
                'Property': 0.5     // Lowest
            };
            const taskMultiplier = taskTypeMultipliers[taskType] || 0.6;
            
            // Duration significance (longer commitments show more intentionality)
            const durationBonus = Math.min(hours * 0.5, 5); // Up to 5 bonus points for long tasks
            
            // GLORIFY GOD (0-35 points) - Highest Priority - Christian World View, Lutheran Missouri Synod
            let glorifyScore = 0;
            
            // Direct Christian/Lutheran themes (25-35 points)
            const directFaithKeywords = ['god', 'jesus', 'christ', 'holy spirit', 'trinity', 'scripture', 'bible', 'prayer', 'worship', 'communion', 'baptism', 'church', 'ministry', 'pastor', 'sermon', 'devotion', 'confession', 'forgiveness'];
            const lutheranKeywords = ['lutheran', 'lcms', 'missouri synod', 'catechism', 'confirmation', 'liturgy', 'sacrament'];
            
            if (directFaithKeywords.some(keyword => text.includes(keyword)) || taskType === 'Church') {
                glorifyScore += lutheranKeywords.some(keyword => text.includes(keyword)) ? 35 : 30;
            }
            // Christian worldview in work/life (18-25 points)
            else if (text.includes('integrity') || text.includes('honesty') || text.includes('stewardship') || text.includes('calling') || text.includes('vocation')) {
                glorifyScore += 20;
            }
            // Self-care as temple care (15-20 points)
            else if (taskType === 'Self' && ['sleep', 'rest', 'health', 'exercise', 'nutrition'].some(keyword => text.includes(keyword))) {
                glorifyScore += 15;
                // Long sleep (7+ hours) shows good stewardship
                if (text.includes('sleep') && hours >= 7) {
                    glorifyScore += 4;
                }
                // Adequate sleep duration bonus
                if (text.includes('sleep') && hours >= 8) {
                    glorifyScore += 3; // Optimal stewardship of body
                }
            }
            // Family as God-given responsibility (12-18 points)
            else if (taskType === 'Family' && (text.includes('raise') || text.includes('teach') || text.includes('guide') || text.includes('love'))) {
                glorifyScore += 15;
            }
            // Property stewardship (10-15 points)
            else if (taskType === 'Property' && (text.includes('maintain') || text.includes('care') || text.includes('repair') || text.includes('improve'))) {
                glorifyScore += 12;
            }
            // Ethical work practices (8-12 points)
            else if (taskType === 'Work' && (text.includes('ethical') || text.includes('honest') || text.includes('fair') || text.includes('quality'))) {
                glorifyScore += 10;
            }
            
            breakdown.G = Math.min(Math.round(glorifyScore * taskMultiplier), 35); // Highest allocation - most important
            totalScore += breakdown.G;
            
            // ENRICH OTHERS (0-25 points) - Second Priority - Help Others, Serve Others, Support Others
            let enrichScore = 0;
            
            // Direct service and helping (18-25 points)
            const serviceKeywords = ['serve', 'service', 'volunteer', 'help', 'assist', 'support', 'care', 'give'];
            const enrichKeywords = ['enrich', 'benefit', 'improve', 'enhance', 'contribute', 'add value', 'make better'];
            const supportKeywords = ['support', 'encourage', 'comfort', 'listen', 'counsel', 'guide', 'advise'];
            
            if (serviceKeywords.some(keyword => text.includes(keyword)) && enrichKeywords.some(keyword => text.includes(keyword))) {
                enrichScore += 25;
                // Long service commitments
                if (hours >= 3) {
                    enrichScore += 3;
                }
            } else if (serviceKeywords.some(keyword => text.includes(keyword))) {
                enrichScore += 22;
            } else if (supportKeywords.some(keyword => text.includes(keyword))) {
                enrichScore += 20;
            }
            // Family care and love (18-22 points)
            else if (taskType === 'Family') {
                enrichScore += 20;
                // Quality time with family
                if (hours >= 2) {
                    enrichScore += 2;
                }
            }
            // Church and ministry service (18-22 points)
            else if (taskType === 'Church') {
                enrichScore += 20;
            }
            // Relationship investment (15-20 points)
            else if (taskType === 'Relationships') {
                enrichScore += 17;
                // Quality time in relationships
                if (hours >= 1) {
                    enrichScore += 2;
                }
            }
            // Work that serves customers/users (12-17 points)
            else if (taskType === 'Work' && (text.includes('customer') || text.includes('user') || text.includes('client'))) {
                enrichScore += 15;
            }
            // Property that benefits others (12-17 points)
            else if (taskType === 'Property' && (text.includes('guest') || text.includes('family') || text.includes('community'))) {
                enrichScore += 15;
            }
            // Self-care that enables service (10-15 points)
            else if (taskType === 'Self' && ['sleep', 'rest', 'health', 'exercise', 'recharge'].some(keyword => text.includes(keyword))) {
                enrichScore += 12;
                // Adequate sleep enables better service
                if (text.includes('sleep') && hours >= 7) {
                    enrichScore += 5; // Well-rested people serve better
                    if (hours >= 8) {
                        enrichScore += 3; // Optimal rest for service
                    }
                }
            }
            
            breakdown.E = Math.min(Math.round(enrichScore * taskMultiplier), 25); // Second highest priority
            totalScore += breakdown.E;
            
            // RAISE UP TEAMS (0-20 points) - Third Priority - Servant Leadership, Build Trust, Empower Others
            let raiseScore = 0;
            
            // Direct leadership and mentoring (15-20 points)
            const leadershipKeywords = ['lead', 'leadership', 'mentor', 'coach', 'guide', 'teach', 'train', 'develop', 'empower', 'inspire', 'motivate', 'delegate'];
            const servantLeaderKeywords = ['servant leadership', 'serve team', 'support team', 'enable', 'facilitate', 'humble'];
            const trustKeywords = ['trust', 'transparency', 'honest', 'reliable', 'dependable', 'integrity', 'credibility'];
            
            if (servantLeaderKeywords.some(keyword => text.includes(keyword))) {
                raiseScore += 20;
            } else if (leadershipKeywords.some(keyword => text.includes(keyword)) && trustKeywords.some(keyword => text.includes(keyword))) {
                raiseScore += 18;
            } else if (leadershipKeywords.some(keyword => text.includes(keyword))) {
                raiseScore += 15;
            }
            // Team collaboration and support (10-15 points)
            else if (text.includes('team') || text.includes('collaborate') || text.includes('meeting') || text.includes('1:1') || text.includes('feedback')) {
                raiseScore += 12;
                // Long meetings show deep investment
                if (hours >= 1 && text.includes('meeting')) {
                    raiseScore += 2;
                }
            }
            // Relationship building (8-12 points)
            else if (taskType === 'Relationships' || (taskType === 'Work' && (text.includes('relationship') || text.includes('network')))) {
                raiseScore += 10;
            }
            // Family leadership (6-10 points)
            else if (taskType === 'Family' && (text.includes('teach') || text.includes('guide') || text.includes('model'))) {
                raiseScore += 8;
            }
            // Personal development for leadership (4-8 points)
            else if (taskType === 'Self' && (text.includes('leadership') || text.includes('communication') || text.includes('skill'))) {
                raiseScore += 6;
            }
            // Self-care enables leadership (recognized with sleep duration)
            else if (taskType === 'Self' && text.includes('sleep')) {
                if (hours >= 7) {
                    raiseScore += 6; // Well-rested leaders are better leaders
                    if (hours >= 8) {
                        raiseScore += 2; // Optimal rest for leadership
                    }
                }
            }
            
            breakdown.R = Math.min(Math.round(raiseScore * taskMultiplier), 20); // Third priority
            totalScore += breakdown.R;
            
            // CREATE SOLUTIONS (0-15 points) - Fourth Priority - Creativity, Learning, Independent Achievement
            let createScore = 0;
            
            // Engineering and technical excellence (12-15 points)
            const engineeringKeywords = ['engineer', 'design', 'build', 'develop', 'code', 'software', 'technical', 'architecture', 'solution'];
            const creativityKeywords = ['creative', 'innovate', 'invent', 'design', 'brainstorm', 'ideate', 'original'];
            const learningKeywords = ['learn', 'study', 'research', 'explore', 'discover', 'understand', 'master'];
            const achievementKeywords = ['achieve', 'accomplish', 'complete', 'deliver', 'execute', 'implement'];
            
            if (engineeringKeywords.some(keyword => text.includes(keyword)) && (creativityKeywords.some(keyword => text.includes(keyword)) || achievementKeywords.some(keyword => text.includes(keyword)))) {
                createScore += 15;
                // Complex engineering projects
                if (hours >= 8) {
                    createScore += 3;
                }
            } else if (engineeringKeywords.some(keyword => text.includes(keyword))) {
                createScore += 13;
            } else if (creativityKeywords.some(keyword => text.includes(keyword)) && learningKeywords.some(keyword => text.includes(keyword))) {
                createScore += 12;
            }
            // Problem solving and innovation (8-12 points)
            else if (text.includes('solve') || text.includes('fix') || text.includes('resolve') || text.includes('troubleshoot')) {
                createScore += 10;
            }
            // Learning and skill development (6-10 points)
            else if (learningKeywords.some(keyword => text.includes(keyword)) || (taskType === 'Self' && text.includes('skill'))) {
                createScore += 8;
                // Deep learning sessions
                if (hours >= 2) {
                    createScore += 2;
                }
            }
            // Work projects and delivery (5-8 points)
            else if (taskType === 'Work' && (text.includes('project') || text.includes('deliver') || text.includes('create'))) {
                createScore += 6;
            }
            // Property improvements and solutions (5-8 points)
            else if (taskType === 'Property' && (text.includes('improve') || text.includes('build') || text.includes('create'))) {
                createScore += 6;
            }
            // Personal creative pursuits (3-6 points)
            else if (taskType === 'Self' && (text.includes('hobby') || text.includes('art') || text.includes('music') || text.includes('write'))) {
                createScore += 4;
            }
            
            breakdown.C = Math.min(Math.round((createScore + durationBonus * 0.4) * taskMultiplier), 15); // Fourth priority
            totalScore += breakdown.C;
            
            // ARCHITECT SYSTEMS (0-10 points) - Fifth Priority - Organizing, Efficiency, Automation
            let architectScore = 0;
            
            // System design and architecture (8-10 points)
            const systemKeywords = ['system', 'architecture', 'framework', 'infrastructure', 'platform', 'design', 'structure'];
            const efficiencyKeywords = ['efficiency', 'optimize', 'streamline', 'automate', 'process', 'workflow', 'lean'];
            const organizingKeywords = ['organize', 'structure', 'plan', 'schedule', 'coordinate', 'manage', 'systematic'];
            
            if (systemKeywords.some(keyword => text.includes(keyword)) && efficiencyKeywords.some(keyword => text.includes(keyword))) {
                architectScore += 10;
                // Complex systems take more time
                if (hours >= 4) {
                    architectScore += 2;
                }
            } else if (systemKeywords.some(keyword => text.includes(keyword))) {
                architectScore += 8;
            } else if (efficiencyKeywords.some(keyword => text.includes(keyword))) {
                architectScore += 7;
            }
            // Organizing and planning (5-8 points)
            else if (organizingKeywords.some(keyword => text.includes(keyword))) {
                architectScore += 6;
            }
            // Work process improvement (4-7 points)
            else if (taskType === 'Work' && (text.includes('improve') || text.includes('process') || text.includes('method'))) {
                architectScore += 5;
            }
            // Property systems and organization (4-7 points)
            else if (taskType === 'Property' && (text.includes('organize') || text.includes('system') || text.includes('plan'))) {
                architectScore += 5;
            }
            // Personal organization systems (3-6 points)
            else if (taskType === 'Self' && (text.includes('routine') || text.includes('habit') || text.includes('organize'))) {
                architectScore += 4;
            }
            // Sleep routine as system architecture
            else if (taskType === 'Self' && text.includes('sleep')) {
                if (hours >= 7 && text.includes('routine')) {
                    architectScore += 4; // Consistent sleep schedule is good systems thinking
                }
            }
            // Family systems and routines (2-5 points)
            else if (taskType === 'Family' && (text.includes('routine') || text.includes('schedule') || text.includes('organize'))) {
                architectScore += 3;
            }
            
            if (systemKeywords.some(keyword => text.includes(keyword)) && efficiencyKeywords.some(keyword => text.includes(keyword))) {
                architectScore += 10;
                // Complex systems take more time
                if (hours >= 4) {
                    architectScore += 2;
                }
            } else if (systemKeywords.some(keyword => text.includes(keyword))) {
                architectScore += 8;
            } else if (efficiencyKeywords.some(keyword => text.includes(keyword))) {
                architectScore += 7;
            }
            // Organizing and planning (5-8 points)
            else if (organizingKeywords.some(keyword => text.includes(keyword))) {
                architectScore += 6;
                // Regular planning sessions
                if ((text.includes('plan') || text.includes('organize')) && (recurrence.toLowerCase() === 'weekly' || recurrence.toLowerCase() === 'daily')) {
                    architectScore += 2;
                }
            }
            // Work process improvement (4-7 points)
            else if (taskType === 'Work' && (text.includes('improve') || text.includes('process') || text.includes('method'))) {
                architectScore += 5;
            }
            // Property systems and organization (4-7 points)
            else if (taskType === 'Property' && (text.includes('organize') || text.includes('system') || text.includes('plan'))) {
                architectScore += 5;
            }
            // Personal organization systems (3-6 points)
            else if (taskType === 'Self' && (text.includes('routine') || text.includes('habit') || text.includes('organize'))) {
                architectScore += 4;
                // Daily routines are systematic
                if (recurrence.toLowerCase() === 'daily') {
                    architectScore += 2;
                }
            }
            // Sleep routine as system architecture
            else if (taskType === 'Self' && text.includes('sleep')) {
                if (hours >= 7 && (recurrence.toLowerCase() === 'daily' || text.includes('routine'))) {
                    architectScore += 4; // Consistent sleep schedule is good systems thinking
                }
            }
            // Family systems and routines (2-5 points)
            else if (taskType === 'Family' && (text.includes('routine') || text.includes('schedule') || text.includes('organize'))) {
                architectScore += 3;
            }
            
            breakdown.A = Math.min(Math.round((architectScore + durationBonus * 0.2) * taskMultiplier), 10); // Lowest priority
            totalScore += breakdown.A;
            
            // Store breakdown for display
            this.lastGraceBreakdown = breakdown;
            
            return Math.min(totalScore, 100);
        }
        
        function exportData() {
            const data = {
                tasks: taskStorage.tasks,
                exportDate: new Date().toISOString(),
                version: '2.0',
                metadata: {
                    totalTasks: taskStorage.tasks.length,
                    completedTasks: taskStorage.tasks.filter(t => t.completed).length,
                    totalHours: taskStorage.tasks.reduce((sum, t) => sum + (parseFloat(t.estimatedTime) || 0), 0),
                    avgGraceScore: taskStorage.tasks.length > 0 
                        ? (taskStorage.tasks.reduce((sum, t) => sum + t.graceScore, 0) / taskStorage.tasks.length).toFixed(1)
                        : 0.0,
                    categoryBreakdown: getCategoryBreakdown()
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `grace-matrix-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('✅ Data exported successfully!', 'success');
        }
        
        function getCategoryBreakdown() {
            const breakdown = { Church: 0, Family: 0, Work: 0, Relationships: 0, Self: 0, Property: 0 };
            taskStorage.tasks.forEach(task => {
                if (breakdown.hasOwnProperty(task.taskType)) {
                    breakdown[task.taskType] += parseFloat(task.estimatedTime) || 0;
                }
            });
            return breakdown;
        }
        
        function importData() {
            document.getElementById('import-file').click();
        }
        
        function exportToCSV() {
            const headers = [
                'Title', 'Description', 'Task Type', 'Estimated Hours', 'Recurrence', 
                'Resources Available', 'Urgency', 'Importance', 'Quadrant', 'GRACE Score', 
                'Completed', 'Created Date', 'Completed Date'
            ];
            
            const csvData = taskStorage.tasks.map(task => [
                `"${task.title.replace(/"/g, '""')}"`,
                `"${(task.description || '').replace(/"/g, '""')}"`,
                task.taskType,
                task.estimatedTime,
                task.recurrence,
                task.resources,
                task.urgency,
                task.importance,
                task.quadrant,
                task.graceScore,
                task.completed ? 'Yes' : 'No',
                new Date(task.createdAt).toLocaleDateString(),
                task.completedAt ? new Date(task.completedAt).toLocaleDateString() : ''
            ].join(','));
            
            const csvContent = [headers.join(','), ...csvData].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `grace-matrix-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('📊 CSV exported successfully!', 'success');
        }
        
        function importFromCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',');
            
            if (!headers.includes('Title') || !headers.includes('Task Type')) {
                throw new Error('Invalid CSV format. Required columns: Title, Task Type');
            }
            
            const tasks = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                
                const values = parseCSVLine(lines[i]);
                if (values.length < headers.length) continue;
                
                const task = {};
                headers.forEach((header, index) => {
                    const cleanHeader = header.trim().replace(/"/g, '');
                    const value = values[index] ? values[index].replace(/"/g, '') : '';
                    
                    switch (cleanHeader) {
                        case 'Title':
                            task.title = value;
                            break;
                        case 'Description':
                            task.description = value;
                            break;
                        case 'Task Type':
                            task.taskType = value;
                            break;
                        case 'Estimated Hours':
                            task.estimatedTime = parseFloat(value) || 1;
                            break;
                        case 'Recurrence':
                            task.recurrence = value || 'Non-recurring';
                            break;
                        case 'Resources Available':
                            task.resources = value || 'Yes';
                            break;
                        case 'Urgency':
                            task.urgency = value || 'low';
                            break;
                        case 'Importance':
                            task.importance = value || 'low';
                            break;
                        case 'Completed':
                            task.completed = value.toLowerCase() === 'yes';
                            break;
                    }
                });
                
                if (task.title && task.taskType) {
                    task.quadrant = determineQuadrant(task.urgency, task.importance, task.resources);
                    task.graceScore = calculateGraceScore(task.title, task.description || '', task.taskType);
                    task.createdAt = new Date().toISOString();
                    task.completedAt = task.completed ? new Date().toISOString() : null;
                    tasks.push(task);
                }
            }
            
            return tasks;
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current);
            return result;
        }
        
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 10px;
                color: white;
                font-weight: 600;
                z-index: 1001;
                transform: translateX(100%);
                transition: transform 0.3s ease;
                box-shadow: 0 10px 20px rgba(0,0,0,0.2);
                ${type === 'success' ? 'background: linear-gradient(135deg, #28a745, #20c997);' : 
                  type === 'error' ? 'background: linear-gradient(135deg, #dc3545, #fd7e14);' : 
                  'background: linear-gradient(135deg, #667eea, #764ba2);'}
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Animate out and remove
            setTimeout(() => {
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        function clearCompleted() {
            if (confirm('Are you sure you want to remove all completed tasks?')) {
                taskStorage.tasks = taskStorage.tasks.filter(task => !task.completed);
                taskStorage.save();
                showNotification('🗑️ Completed tasks cleared!', 'success');
            }
        }
        
        function updatePerformanceScore(taskId, score) {
            const numericScore = parseFloat(score);
            
            // Validate score range
            if (score === '' || score === null) {
                // Allow empty score
                taskStorage.updateTask(taskId, { performanceScore: null });
                return;
            }
            
            if (isNaN(numericScore) || numericScore < 0 || numericScore > 100) {
                alert('Performance score must be between 0 and 100');
                return;
            }
            
            // Update the task with new performance score
            taskStorage.updateTask(taskId, { performanceScore: numericScore });
            
            // Show success message
            showNotification(`📊 Performance score updated: ${numericScore}%`, 'success');
        }
        
        let currentPerformanceTaskId = null;
        
        function openPerformanceModal(taskId) {
            const task = taskStorage.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            currentPerformanceTaskId = taskId;
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'performanceModal';
            modal.className = 'modal';
            modal.style.display = 'block';
            
            modal.innerHTML = `
                <div class="performance-input-modal">
                    <h4>Set Performance Score for: ${task.title}</h4>
                    <input type="number" 
                           id="performance-score-input" 
                           placeholder="Enter score (0-100)" 
                           min="0" 
                           max="100" 
                           value="${task.performanceScore || ''}"
                           autofocus>
                    <div class="button-group">
                        <button onclick="savePerformanceScore()" style="background: linear-gradient(135deg, #28a745, #20c997);">Save</button>
                        <button onclick="clearPerformanceScore()" style="background: linear-gradient(135deg, #6c757d, #495057);">Clear</button>
                        <button onclick="closePerformanceModal()" class="secondary-btn">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Focus the input
            setTimeout(() => {
                document.getElementById('performance-score-input').focus();
            }, 100);
            
            // Handle Enter key
            document.getElementById('performance-score-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    savePerformanceScore();
                }
            });
            
            // Handle clicking outside modal
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closePerformanceModal();
                }
            });
        }
        
        function savePerformanceScore() {
            const input = document.getElementById('performance-score-input');
            const score = input.value.trim();
            
            if (score === '') {
                clearPerformanceScore();
                return;
            }
            
            const numericScore = parseFloat(score);
            
            if (isNaN(numericScore) || numericScore < 0 || numericScore > 100) {
                alert('Performance score must be between 0 and 100');
                input.focus();
                return;
            }
            
            updatePerformanceScore(currentPerformanceTaskId, numericScore);
            closePerformanceModal();
        }
        
        function clearPerformanceScore() {
            updatePerformanceScore(currentPerformanceTaskId, null);
            closePerformanceModal();
            showNotification('🔄 Performance score cleared', 'info');
        }
        
        function closePerformanceModal() {
            const modal = document.getElementById('performanceModal');
            if (modal) {
                document.body.removeChild(modal);
            }
            currentPerformanceTaskId = null;
        }
        
        function toggleScheduled(taskId) {
            const task = taskStorage.tasks.find(t => t.id === taskId);
            if (task) {
                task.isScheduled = !task.isScheduled;
                taskStorage.save();
                
                const statusText = task.isScheduled ? 'scheduled externally' : 'not scheduled';
                const emoji = task.isScheduled ? '📅' : '❌';
                showNotification(`${emoji} Task ${statusText}: ${task.title}`, task.isScheduled ? 'success' : 'info');
            }
        }
        
        function clearFilters() {
            document.getElementById('filter-task-type').value = '';
            document.getElementById('filter-recurrence').value = '';
            taskStorage.renderAllTasks();
            showNotification('🔄 Filters cleared!', 'info');
        }
        
        function applyFilters() {
            taskStorage.renderAllTasks();
        }
        
        // Event listeners
        document.getElementById('import-file').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    let importedTasks = [];
                    
                    if (file.name.endsWith('.json')) {
                        // Handle JSON import
                        const data = JSON.parse(content);
                        if (data.tasks && Array.isArray(data.tasks)) {
                            importedTasks = data.tasks;
                        } else {
                            throw new Error('Invalid JSON format. Expected tasks array.');
                        }
                    } else if (file.name.endsWith('.csv')) {
                        // Handle CSV import
                        importedTasks = importFromCSV(content);
                    } else {
                        throw new Error('Unsupported file format. Please use JSON or CSV files.');
                    }
                    
                    if (importedTasks.length === 0) {
                        showNotification('⚠️ No valid tasks found in the file', 'error');
                        return;
                    }
                    
                    const action = confirm(
                        `Found ${importedTasks.length} tasks to import.\n\n` +
                        `Choose OK to REPLACE all current tasks, or Cancel to MERGE with existing tasks.`
                    );
                    
                    if (action === true) {
                        // Replace all tasks
                        taskStorage.tasks = importedTasks.map(task => ({
                            ...task,
                            id: taskStorage.nextId++
                        }));
                        showNotification(`✅ Replaced with ${importedTasks.length} tasks!`, 'success');
                    } else if (action === false) {
                        // Merge tasks
                        importedTasks.forEach(task => {
                            task.id = taskStorage.nextId++;
                            taskStorage.tasks.push(task);
                        });
                        showNotification(`✅ Added ${importedTasks.length} new tasks!`, 'success');
                    } else {
                        showNotification('❌ Import cancelled', 'info');
                        return;
                    }
                    
                    taskStorage.save();
                    
                } catch (error) {
                    showNotification('❌ Import failed: ' + error.message, 'error');
                    console.error('Import error:', error);
                }
            };
            
            reader.readAsText(file);
            this.value = '';
        });
        
        // Modal event listeners
        document.querySelector('.close').onclick = closeEditModal;
        window.onclick = function(event) {
            const modal = document.getElementById('editModal');
            if (event.target === modal) {
                closeEditModal();
            }
        };
        
        // Enter key support
        document.getElementById('item-title').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') addItem();
        });
        
        // Filter event listeners
        document.getElementById('filter-task-type').addEventListener('change', applyFilters);
        document.getElementById('filter-recurrence').addEventListener('change', applyFilters);
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Show loading message
            taskStorage.showNotification('🔄 Loading your GRACE matrix...', 'info');
            
            // Initialize storage system
            taskStorage.init().then(() => {
                taskStorage.showNotification('✅ GRACE matrix loaded successfully!', 'success');
            }).catch((error) => {
                console.error('Initialization failed:', error);
                taskStorage.showNotification('⚠️ Using temporary storage - data will not persist', 'error');
            });
        });
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRACE-Eisenhower Priority Matrix</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 100vw;
            width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            padding: 40px;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }
        
        .header h1 {
            color: #2c3e50;
            margin: 0 0 15px 0;
            font-size: 2.2em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .grace-subtitle {
            color: #7f8c8d;
            font-size: 1em;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .grace-framework {
            color: #2c3e50;
            padding: 20px;
            margin-bottom: 40px;
            text-align: center;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            border: 1px solid #dee2e6;
        }
        
        .grace-items {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .grace-item {
            padding: 12px 15px;
            font-size: 1em;
            font-weight: 600;
            color: #2c3e50;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .grace-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }
        
        .time-allocation-chart {
            background: rgba(255,255,255,0.9);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        
        .chart-section h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .pie-chart {
            width: 280px;
            height: 280px;
            margin: 0 auto 20px;
            position: relative;
        }
        
        .pie-chart svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        
        .pie-slice {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .pie-slice:hover {
            opacity: 0.8;
            transform: scale(1.05);
            transform-origin: center;
        }
        
        .chart-legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .legend-entry {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(255,255,255,0.7);
            border-radius: 8px;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }
        
        .legend-entry:hover {
            background: rgba(255,255,255,0.9);
            transform: translateY(-1px);
        }
        
        .legend-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .legend-text {
            font-weight: 500;
            color: #2c3e50;
        }
        
        .no-data-message {
            color: #6c757d;
            font-style: italic;
            padding: 40px;
            background: rgba(255,255,255,0.5);
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .stats-bar {
            display: flex;
            justify-content: space-around;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            display: block;
        }
        
        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
            font-weight: 500;
        }
        
        .matrix-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: minmax(200px, auto) minmax(400px, auto) minmax(150px, auto) minmax(150px, auto);
            gap: 15px;
            margin-bottom: 40px;
            border: 3px solid #2c3e50;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            width: 100%;
            max-width: 100%;
        }
        
        .quadrant {
            padding: 15px 15px 60px 15px;
            border: 2px solid #ecf0f1;
            position: relative;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
            display: flex;
            flex-direction: column;
            word-wrap: break-word;
        }
        
        .quadrant:hover {
            transform: scale(1.01);
            box-shadow: 0 15px 30px rgba(0,0,0,0.15);
            z-index: 1;
        }
        
        .quadrant-held {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            color: #495057;
            grid-column: 1 / -1;
            position: relative;
        }
        
        .quadrant-completed {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            color: #155724;
            grid-column: 1 / -1;
            position: relative;
        }
        
        .quadrant-1 {
            background: linear-gradient(135deg, #a8e6cf, #7fcdcd);
            color: #2c3e50;
        }
        
        .quadrant-2 {
            background: linear-gradient(135deg, #ffd3a5, #fdb99b);
            color: #2c3e50;
        }
        
        .quadrant-3 {
            background: linear-gradient(135deg, #c5a3ff, #f093fb);
            color: #2c3e50;
        }
        
        .quadrant-4 {
            background: linear-gradient(135deg, #ffa8b6, #ffb6a3);
            color: #2c3e50;
        }
        
        .quadrant-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .quadrant-count {
            background: rgba(255,255,255,0.7);
            color: #2c3e50;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: normal;
        }
        
        .quadrant-subtitle {
            font-size: 1em;
            opacity: 0.8;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .quadrant-grace-score {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(255,255,255,0.8);
            color: #2c3e50;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.7em;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.5);
            z-index: 10;
            pointer-events: none;
        }
        
        .quadrant-performance-score {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(255,255,255,0.8);
            color: #2c3e50;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.7em;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.5);
            z-index: 10;
            pointer-events: none;
        }
        
        .performance-input {
            background: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.4);
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-size: 0.7em;
            width: 40px;
            text-align: center;
            margin-left: 5px;
        }
        
        .performance-input:focus {
            outline: none;
            background: rgba(255,255,255,0.5);
        }
        
        .performance-input::placeholder {
            color: rgba(255,255,255,0.7);
        }
        
        .scheduled-checkbox {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            cursor: pointer;
            accent-color: #28a745;
            flex-shrink: 0;
        }
        
        .scheduled-indicator {
            display: inline-flex;
            align-items: center;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.65em;
            font-weight: bold;
            margin-left: 6px;
            border: 1px solid rgba(255,255,255,0.3);
            flex-shrink: 0;
        }
        
        .scheduled-indicator.scheduled {
            background: rgba(40, 167, 69, 0.3);
            border-color: rgba(40, 167, 69, 0.5);
            color: #d4edda;
        }
        
        .scheduled-indicator.not-scheduled {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
            color: #f8d7da;
        }
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 8px;
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }
        
        .performance-circle:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .performance-circle.no-score {
            background: #6c757d;
            border-color: #6c757d;
        }
        
        .performance-circle.low-score {
            background: #dc3545;
            border-color: #dc3545;
            animation: pulse-red 2s infinite;
        }
        
        .performance-circle.mid-score {
            background: #ffc107;
            border-color: #ffc107;
            color: #333;
        }
        
        .performance-circle.high-score {
            background: #28a745;
            border-color: #28a745;
            animation: pulse-green 3s infinite;
        }
        
        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes pulse-green {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .performance-input-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 2000;
            min-width: 300px;
        }
        
        .performance-input-modal h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
        }
        
        .performance-input-modal input {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        .performance-input-modal .button-group {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .performance-input-modal button {
            padding: 8px 16px;
            font-size: 14px;
        }
        
        .items-list {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: visible;
            padding-bottom: 20px;
            margin-bottom: 20px;
        }
        
        .item {
            background: rgba(255,255,255,0.4);
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 8px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .item:hover {
            background: rgba(255,255,255,0.6);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .item.completed {
            opacity: 0.6;
            background: rgba(255,255,255,0.25);
        }
        
        .item.completed .item-title {
            text-decoration: line-through;
        }
        
        .item-content {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
        }
        
        .item-title-text {
            font-weight: 600;
            font-size: 0.75em;
            color: inherit;
            margin: 0;
            line-height: 1.2;
            word-wrap: break-word;
            overflow-wrap: break-word;
            flex: 1;
            min-width: 0;
        }
        
        .item-details {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
            font-size: 0.7em;
            opacity: 0.9;
        }
        
        .item-duration {
            background: rgba(255,255,255,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .item-recurrence {
            background: rgba(255,255,255,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .item-controls-row {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .scheduled-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #28a745;
            flex-shrink: 0;
        }
        
        .scheduled-label {
            font-size: 0.65em;
            color: inherit;
            opacity: 0.8;
            margin-left: 2px;
            flex-shrink: 0;
        }
        
        .task-type-section {
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
        }
        
        .task-type-header {
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .task-type-header .grace-average {
            font-size: 0.8em;
            background: rgba(255,255,255,0.3);
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: normal;
        }
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6em;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }
        
        .performance-circle:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .completion-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #667eea;
            flex-shrink: 0;
        }
        
        .delete-btn {
            background: rgba(220, 53, 69, 0.7);
            border: none;
            padding: 4px 6px;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.7em;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            opacity: 0;
            pointer-events: none;
        }
        
        .item:hover .delete-btn {
            opacity: 1;
            pointer-events: auto;
        }
        
        .delete-btn:hover {
            background: rgba(220, 53, 69, 0.9);
            transform: scale(1.1);
        }
        
        .item.completed .item-title {
            text-decoration: line-through;
        }
        
        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(20px) scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }
        
        .item-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .item:hover .item-controls {
            opacity: 1;
        }
        
        .control-btn {
            background: rgba(255,255,255,0.3);
            border: none;
            padding: 4px 6px;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.5);
            transform: scale(1.1);
        }
        
        .calendar-link {
            display: inline-block;
            background: rgba(255,255,255,0.3);
            padding: 6px 12px;
            border-radius: 15px;
            text-decoration: none;
            color: white;
            font-size: 0.8em;
            margin-top: 8px;
            border: 1px solid rgba(255,255,255,0.4);
            transition: all 0.3s ease;
        }
        
        .calendar-link:hover {
            background: rgba(255,255,255,0.5);
            transform: translateY(-1px);
        }
        
        .item-title {
            font-weight: 600;
            font-size: 0.8em;
            color: inherit;
            margin: 0;
            padding-right: 70px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            min-font-size: 8px;
        }
        
        .item-priority {
            font-size: 0.75em;
            opacity: 0.8;
            margin-top: 4px;
            font-weight: 500;
        }
        
        .grace-indicator {
            display: inline-block;
            background: rgba(255,255,255,0.3);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            margin-top: 4px;
        }
        
        .input-section {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 30px;
            border-radius: 15px;
            margin-top: 30px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
        
        .input-section h3 {
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .optional-fields {
            margin-bottom: 20px;
        }
        
        .optional-fields input,
        .optional-fields select {
            color: #888 !important;
        }
        
        .optional-fields input::placeholder {
            color: #aaa !important;
        }
        
        input[type="text"], input[type="number"], select, textarea {
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: white;
        }
        
        input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }
        
        textarea {
            resize: vertical;
            min-height: 80px;
            grid-column: 1 / -1;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
        }
        
        .secondary-btn {
            background: linear-gradient(135deg, #6c757d, #495057);
        }
        
        .secondary-btn:hover {
            box-shadow: 0 15px 30px rgba(108, 117, 125, 0.4);
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            background: rgba(255,255,255,0.5);
            border-radius: 10px;
            transition: all 0.3s ease;
        }
        
        .legend-item:hover {
            background: rgba(255,255,255,0.8);
            transform: translateY(-2px);
        }
        
        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            flex-shrink: 0;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close:hover {
            color: #667eea;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .filter-section {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
        
        .filter-section h3 {
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .filter-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .filter-controls select {
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            min-width: 180px;
        }
        
        .filter-controls select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .unutilized-time-display {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
            text-align: center;
            border: 2px solid #dee2e6;
        }
        
        .unutilized-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
        }
        
        .unutilized-values {
            font-size: 1.3em;
            font-weight: bold;
            color: #667eea;
        }
        
        .unutilized-values span {
            color: #28a745;
        }
        
        @media (max-width: 768px) {
            .matrix-container {
                grid-template-columns: 1fr;
                grid-template-rows: minmax(200px, auto) minmax(200px, auto) minmax(400px, auto) minmax(400px, auto) minmax(150px, auto) minmax(150px, auto);
                min-height: auto;
            }
            
            .quadrant-held {
                grid-column: 1;
            }
            
            .quadrant-completed {
                grid-column: 1;
            }
            
            .input-group {
                grid-template-columns: 1fr;
            }
            
            .grace-items {
                flex-direction: column;
                align-items: center;
            }
            
            .pie-chart {
                width: 250px;
                height: 250px;
            }
            
            .charts-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
        
        @media (max-width: 480px) {
            .container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .quadrant {
                padding: 15px;
            }
            
            .stats-bar {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Print Styles */
        @media print {
            body {
                background: white !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            .container {
                max-width: 100% !important;
                box-shadow: none !important;
                border-radius: 0 !important;
                padding: 20px !important;
                page-break-inside: avoid;
            }
            
            .container::before {
                display: none;
            }
            
            .input-section, .button-group, .filter-section {
                display: none !important;
            }
            
            .matrix-container {
                gap: 10px !important;
                min-height: 350px !important;
                page-break-inside: avoid;
            }
            
            .quadrant {
                padding: 10px !important;
                min-height: 120px !important;
                break-inside: avoid;
            }
            
            .quadrant-title {
                font-size: 1.2em !important;
            }
            
            .item-title {
                font-size: max(8px, 0.7em) !important;
            }
            
            .time-allocation-chart {
                page-break-inside: avoid;
                margin-top: 20px !important;
            }
            
            .charts-container {
                grid-template-columns: 1fr 1fr !important;
            }
            
            .pie-chart {
                width: 200px !important;
                height: 200px !important;
            }
            
            .legend {
                page-break-inside: avoid;
            }
            
            .progress-bar {
                display: none !important;
            }
        }
        
        /* Responsive Font Scaling */
        @media (max-width: 1200px) {
            .item-title {
                font-size: max(8px, 0.75em);
            }
            
            .quadrant-title {
                font-size: 1.3em;
            }
        }
        
        @media (max-width: 900px) {
            .item-title {
                font-size: max(8px, 0.7em);
            }
            
            .quadrant-title {
                font-size: 1.2em;
            }
            
            .quadrant {
                padding: 12px;
            }
        }
